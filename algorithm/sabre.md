# 基础
## 数组
* 长度n的数组里的数字都在0~n-1范围[2, 3, 1, 0, 2, 5, 3]，找出重复数字
数组的第0项是2，和下标不相等，则与第2项交换，[1, 3, 2, 0, 2, 5, 3] -> [3, 1, 2, 0, 2, 5, 3] -> [0, 1, 2, 3, 2, 5, 3] 则在第4/6找到重复
时间`O(n)`，空间`O(1)`

* 上述题目，不修改数组找出重复文字
  1. 创建新数组，按角标赋值，时间`O(n)`，空间`O(n)`
  2. 二分法，找出中间数字n来模拟分为两部分，长度超过n的部分继续进行二分，但不能判断每个数字出现几次。时间`O(n*logn)`空间`O(1)`

## 二维数组
* 每一行按从左到右，每一列按从上到下递增，输入这样一个二维数组，判断数组中是否有该整数
```
1 2 8 9
2 4 9 12
4 7 10 13
6 8 11 15
```
选取右上数字如果大于要查找的数字，则剔除所在列，小于则剔除所在行，等于则返回，没找到返回空。空间`O(1)`时间`O(m + n)`

## 字符串
* 实现一个函数，将字符串每个空格替换为`%20`
**时间复杂度为O(n^2)会挂掉哦**
将一个字符替换为3个存在后移过程
从字符串尾开始赋值和替换。准备两个指针：P1和P2，P1指向原始字符串末尾，P2指向替换之后字符串末尾。向前移动P1，复制字符到P2指向的位置，直到碰到第一个空格后，P1向前1格，P2插入`%20`后前移3格。依次类推，P1和P2指向同一位置，表示所有空格替换完成。
所有字符只复制（移动）一次，时间效率为O(n)

## 链表
* 从尾到头打印链表
**不允许修改输入的数据**
* 后进先出，可以用栈实现。每经过一个节点，把该节点，放到一个栈，遍历完整个列表，再从栈顶输出节点的值，即可翻转`t=O(2n)`
* 每访问到一个节点，先递归输出后面的节点，再输出自身。`t=O(n)`

## 二叉树
* 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树
首先找到根节点，即前序遍历的第一个节点，接着找到该节点值在中序遍历的位置i，可以得到左子树为前序遍历的[1, i]中序遍历的[0, i - 1]右子树为前序遍历的[i + 1, n]中序遍历的[i + 1, n]，分别对左右子树做此递归。

* 给定一颗二叉树和其中一个节点，如何找出中序遍历的下一个节点？
如果一个节点有右子树，它的中序遍历下一个节点就是右子树中的最左节点。
如果该节点是父节点的左子节点，没有右子树，下一个节点就是父节点。
如果该节点是父节点的右子节点，需要向上遍历，找到一个是父节点左子节点的节点，该节点的父节点就是下一个节点。

## 栈和队列
用两个栈实现队列
