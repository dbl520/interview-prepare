# 无序限定范围的数组元素查找

41. 缺失的第一个正数
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

示例 1:
```
输入: [1,2,0]
输出: 3
```
示例 2:
```
输入: [3,4,-1,1]
输出: 2
```
示例 3:
```
输入: [7,8,9,11,12]
输出: 1
```

提示：
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。

思路：
对于一个长度为 N 的数组，其中没有出现的最小正整数只能在 [1, N+1]中。这是因为如果 [1, N]都出现了，那么答案是 N+1否则答案是[1, N]中没有出现的最小正整数。直接使用位置映射：值x对应位置x-1
对于值在[1, n]区间范围的数打上标记（转为负数），如果都被打上标记，返回n + 1，否则返回最小没被打标记数的位置+1

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
  let n = nums.length
  // 处理负数，并将边界+1
  for (var i = 0; i <= n + 1; i++) {
     if (nums[i] <= 0 || !nums[i]) nums[i] = n + 1;
  }
  // 对于值在[1, n]区间范围的数打上标记
  for (var i = 0; i < n; i++) {
    let x = Math.abs(nums[i])
    // 在第 |x| - 1个位置的数添加一个负号(值映射到位置)
    nums[x - 1] = - Math.abs(nums[x - 1]);
  }
  // 找出第一个正数返回其下标+1
  for (var i = 0; i < n + 1; i++) {
    if (nums[i] > 0) return i + 1
  }
};
```
